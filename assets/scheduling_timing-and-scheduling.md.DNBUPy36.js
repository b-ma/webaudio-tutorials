import{c as a,m as n,p as e,a3 as s,o as l,g as o}from"./chunks/framework.Wgqp_vq1.js";const t="/webaudio-tutorials/assets/fixed-scheduling.LairGNGB.png",p="/webaudio-tutorials/assets/naive-lookahead.BhhZte_S.png",c="/webaudio-tutorials/assets/late-callback.C3viS2Pt.png",i="/webaudio-tutorials/assets/period-and-lookahead.BFBHNTNH.png",r=s(`<h1 id="timing-and-scheduling" tabindex="-1">Timing and Scheduling <a class="header-anchor" href="#timing-and-scheduling" aria-label="Permalink to &quot;Timing and Scheduling&quot;">​</a></h1><p>In this tutorial we will focus on one of the most important aspects of any audio application, that is how to organize events in time. More precisely, we will review the possibilities and possible limitations of functionalities provided by the Web Audio API, and we will learn how these limitations can be mitigated by using a lookahead scheduler.</p><h3 id="related-documentation" tabindex="-1">Related documentation <a class="header-anchor" href="#related-documentation" aria-label="Permalink to &quot;Related documentation&quot;">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/currentTime" target="_blank" rel="noreferrer"><code>AudioContext.currentTime</code></a></li><li><a href="https://web.dev/articles/audio-scheduling" target="_blank" rel="noreferrer"><code>A tale of two clocks - C. Wilson</code></a></li></ul><h2 id="clocks-and-times" tabindex="-1">Clocks and times <a class="header-anchor" href="#clocks-and-times" aria-label="Permalink to &quot;Clocks and times&quot;">​</a></h2><p>As we have seen in previous tutorials, the Web Audio API already provides us a clock and some ways of controlling some timing aspects over playback and synthesis.</p><p>Let&#39;s first consider the clock provided by the Web Audio API:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span></code></pre></div><p>The <code>currentTime</code> attribute of the <code>AudioContext</code> gives us the time in seconds since the <code>AudioContext</code> has been resumed. This clock is computed as: <code>number of samples / sample rate</code> and is therefore accurate in terms of audio time.</p><p>However, it has one major limitation: it is re-computed once at each block of processing (i.e. at block rate or <code>k-rate</code>) or every 128 samples. For example, at 44.1kHz this means that it will advance by steps of <code>128 / 44100</code> seconds or ~2.9 milliseconds. In practical terms this means that accessing <code>audioContext.currentTime</code> will always give you the time of the next block that will be computed.</p><p>In terms of scheduling, we have already seen different methods that allow us to achieve such thing. For example we can <code>start</code> and <code>stop</code> sources at a given time:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> src </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.</span><span style="color:#A6E22E;">createBufferSourceNode</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">src.buffer </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> buffer;</span></span>
<span class="line"><span style="color:#F8F8F2;">src.</span><span style="color:#A6E22E;">connect</span><span style="color:#F8F8F2;">(audioContext.destination);</span></span>
<span class="line"><span style="color:#88846F;">// start the source in 1 sec and stop it in 3 seconds from now</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span>
<span class="line"><span style="color:#F8F8F2;">src.</span><span style="color:#A6E22E;">start</span><span style="color:#F8F8F2;">(now </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">src.</span><span style="color:#A6E22E;">stop</span><span style="color:#F8F8F2;">(now </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 3</span><span style="color:#F8F8F2;">);</span></span></code></pre></div><p>Additionally, all automation methods of <code>AudioParams</code> can be scheduled in a similar way:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> envelop </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.</span><span style="color:#A6E22E;">createGain</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">envelop.gain.value </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0</span><span style="color:#F8F8F2;">; </span><span style="color:#88846F;">// set the gain default value to 0</span></span>
<span class="line"><span style="color:#88846F;">// create an envelop that will start in 1 second and end in 3 seconds</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span>
<span class="line"><span style="color:#88846F;"> // create at start automation point</span></span>
<span class="line"><span style="color:#F8F8F2;">envelop.</span><span style="color:#A6E22E;">setValueAtTime</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">, now </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#88846F;"> // ramp linearly to 1 in 20 ms</span></span>
<span class="line"><span style="color:#F8F8F2;">envelop.</span><span style="color:#A6E22E;">linearRampToValueValueAtTime</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">1</span><span style="color:#F8F8F2;">, now </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 0.02</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#88846F;">// ramp exponetialy to (almost) 0 at second 3 after now</span></span>
<span class="line"><span style="color:#F8F8F2;">envelop.</span><span style="color:#A6E22E;">exponentialRampToValueAtTime</span><span style="color:#F8F8F2;">(</span><span style="color:#AE81FF;">0.001</span><span style="color:#F8F8F2;">, now </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 3</span><span style="color:#F8F8F2;">);</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The <code>exponentialRampToValueAtTime</code> will throw an <code>Error</code> if it&#39;s target value is 0, because it is undefined mathematically. A practical way of finding a good value is to remember that this correspondence between linear and dB values:</p><ul><li>1 -&gt; 0 dB</li><li>0.1 -&gt; -20dB</li><li>0.01 -&gt; -40dB</li><li>0.001 -&gt; -60dB</li><li>... In the example above, this means that the target we set correspond to -80 dB which low enough so that the corresponding source can be stop without earring any discontinuity.</li></ul></div><p>All these methods are indeed very practical and powerful, as they allow us to schedule events, for example a metronome, very precisely at the sub sample level:</p><p><img src="`+t+'" alt="fixed-scheduling"></p><p>However, such approach suffers one major limitation: we have to know every single event that will occur in our score (or application) to schedule them all at once in a very precise way. Indeed, this is not very suited for more interactive or reactive applications.</p><h2 id="principles-of-a-lookahead-scheduler" tabindex="-1">Principles of a lookahead scheduler <a class="header-anchor" href="#principles-of-a-lookahead-scheduler" aria-label="Permalink to &quot;Principles of a lookahead scheduler&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The concepts presented in this section are mostly a digest of the article <a href="https://web.dev/articles/audio-scheduling" target="_blank" rel="noreferrer">&quot;A Tale of two Clocks&quot; by Chris Wilson</a>. We highly recommend you to read this article and come back to the tutorial afterwards.</p></div><p>To workaround this limitation, one possible way is two periodically check if what have things to schedule in the near future (the &quot;lookahead&quot;) until we check it again. As such, it becomes possible to react to external events such as a change of tempo:</p><p><img src="'+p+`" alt="naive-lookahead"></p><p>Which we could write in (pseudo) JavaScript code:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> lookahead </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0.1</span><span style="color:#F8F8F2;">; </span><span style="color:#88846F;">// in second</span></span>
<span class="line"><span style="color:#88846F;">// a function that looks for events between now and now + lookahead</span></span>
<span class="line"><span style="color:#88846F;">// and schedule all audio events that have been found</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#A6E22E;"> tick</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> events </span><span style="color:#F92672;">=</span><span style="color:#A6E22E;"> findEventsBetween</span><span style="color:#F8F8F2;">(now, now </span><span style="color:#F92672;">+</span><span style="color:#F8F8F2;"> lookahead);</span></span>
<span class="line"><span style="color:#F8F8F2;">    events.</span><span style="color:#A6E22E;">forEach</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">event</span><span style="color:#66D9EF;font-style:italic;"> =&gt;</span><span style="color:#A6E22E;"> scheduleAudioEvent</span><span style="color:#F8F8F2;">(event));</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// Execute the \`tick\` function every 100 ms</span></span>
<span class="line"><span style="color:#88846F;">// note that the \`setInterval\` period (2nd argument) is defined in ms</span></span>
<span class="line"><span style="color:#A6E22E;">setInterval</span><span style="color:#F8F8F2;">(tick, lookahead </span><span style="color:#F92672;">*</span><span style="color:#AE81FF;"> 1000</span><span style="color:#F8F8F2;">);</span></span></code></pre></div><p>With such approach, we can maintain and modify a list of event, in which our <code>findEventsBetween</code> function will look for events, and react quite rapidly to any change in the list as only the events registered in the next 100 ms are already scheduled in terms of audio rendering.</p><p>So theoretically, we are all good! However with such naive approach, we just fall into another trap. Indeed, as we have seen in the previous tutorial, the JavaScript timing functions: <code>setInterval</code> and <code>setTimeout</code> are not accurate enough to precisely schedule audio events. And furthermore, as we have just seen, the <code>audioContext.currentTime</code> is not continuous neither... Thus this is very possible to end up with a situation such as:</p><p><img src="`+c+'" alt="late-callback"></p><p>Where an events is dropped (start in red) because the callback has been called too late!</p><p>To fix this issue we thus need to decouple the rate at which the callback is called (i.e. its period) and the lookahead, making sure that the period is always lower than the lookahead. With such strategy, we can thus mitigate the accuracy of the <code>setInterval</code> and recover if the callback is not called precisely at the expected time (which <strong><em>will</em></strong> be the case):</p><p><img src="'+i+`" alt="period-and-lookahead"></p><p>In our pseudo code implementation, that would mean:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">// define \`lookahead\` and \`period\` such as period &lt; lookahead</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> lookahead </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0.15</span><span style="color:#F8F8F2;">; </span><span style="color:#88846F;">// in second</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> period </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0.1</span><span style="color:#F8F8F2;">; </span><span style="color:#88846F;">// in second</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// Schedule events between now and now + lookahead</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#A6E22E;"> tick</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> events </span><span style="color:#F92672;">=</span><span style="color:#A6E22E;"> findEventsBetween</span><span style="color:#F8F8F2;">(now, now </span><span style="color:#F92672;">+</span><span style="color:#F8F8F2;"> lookahead);</span></span>
<span class="line"><span style="color:#F8F8F2;">    events.</span><span style="color:#A6E22E;">forEach</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">event</span><span style="color:#66D9EF;font-style:italic;"> =&gt;</span><span style="color:#A6E22E;"> scheduleAudioEvent</span><span style="color:#F8F8F2;">(event));</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// Execute the \`tick\` at \`period\`</span></span>
<span class="line"><span style="color:#A6E22E;">setInterval</span><span style="color:#F8F8F2;">(tick, period </span><span style="color:#F92672;">*</span><span style="color:#AE81FF;"> 1000</span><span style="color:#F8F8F2;">);</span></span></code></pre></div><p>Now that we have a basic understanding of what lookahead schedulers are and why we need them in interactive applications, let&#39;s implement a simple but working one.</p><h2 id="implement-a-simple-lookahead-scheduler" tabindex="-1">Implement a simple lookahead scheduler <a class="header-anchor" href="#implement-a-simple-lookahead-scheduler" aria-label="Permalink to &quot;Implement a simple lookahead scheduler&quot;">​</a></h2><h3 id="scaffold-project" tabindex="-1">Scaffold project <a class="header-anchor" href="#scaffold-project" aria-label="Permalink to &quot;Scaffold project&quot;">​</a></h3><p>So let&#39;s first scaffold a new project:</p><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;">cd</span><span style="color:#E6DB74;"> ~/Desktop/webaudio-tutorials</span></span>
<span class="line"><span style="color:#A6E22E;">npx</span><span style="color:#E6DB74;"> @ircam/create@latest</span><span style="color:#AE81FF;"> 05</span><span style="color:#E6DB74;">-lookahead-scheduler</span></span>
<span class="line"><span style="color:#66D9EF;">cd</span><span style="color:#AE81FF;"> 05</span><span style="color:#E6DB74;">-lookahead-scheduler</span></span>
<span class="line"><span style="color:#A6E22E;">npx</span><span style="color:#E6DB74;"> serve</span></span></code></pre></div><h3 id="priority-queue" tabindex="-1">Priority queue <a class="header-anchor" href="#priority-queue" aria-label="Permalink to &quot;Priority queue&quot;">​</a></h3><p>A <a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="noreferrer">priority queue</a> is a data structure where each element has an associated priority and that guarantees that elements with higher priority are retrieved before elements with lower priority. In our case, when looking for the next event to be scheduled, we want to be sure that this is the event which is scheduled in the closest future.</p><p>We won&#39;t go into how to implement such data structure in an efficient way and will just use a list of event sorted according to their associated time. What we want want to be able to do with this queue is:</p><ul><li>add an event with an associated priority (i.e. a time)</li><li>read the item with the highest priority (i.e. smallest time)</li><li>remove the item with highest priority (when it has been scheduled)</li></ul><p>So let&#39;s go with implementing the queue:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">// ./main.js</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> audioContext </span><span style="color:#F92672;">=</span><span style="color:#F92672;"> new</span><span style="color:#A6E22E;"> AudioContext</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F92672;">await</span><span style="color:#A6E22E;"> resumeAudioContext</span><span style="color:#F8F8F2;">(audioContext);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> buffer </span><span style="color:#F92672;">=</span><span style="color:#F92672;"> await</span><span style="color:#A6E22E;"> loadAudioBuffer</span><span style="color:#F8F8F2;">(</span><span style="color:#E6DB74;">&#39;./assets/sample.wav&#39;</span><span style="color:#F8F8F2;">, audioContext.sampleRate);</span></span>
<span class="line"></span>
<span class="line highlighted"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">PriorityQueue</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line highlighted"><span style="color:#66D9EF;font-style:italic;">  constructor</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line highlighted"><span style="color:#88846F;">    // array in which we store the elements of the queue</span></span>
<span class="line highlighted"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.queue </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> [];</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">  }</span></span>
<span class="line highlighted"><wbr></span>
<span class="line highlighted"><span style="color:#88846F;">  // add an event with it&#39;s associated priority into the queue</span></span>
<span class="line highlighted"><span style="color:#A6E22E;">  add</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">event</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">time</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line highlighted"><span style="color:#88846F;">    // pack \`event\` and \`time\` into a single data structure</span></span>
<span class="line highlighted"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> element </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> { event, time };</span></span>
<span class="line highlighted"><span style="color:#88846F;">    // add the data structure into the queue</span></span>
<span class="line highlighted"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.queue.</span><span style="color:#A6E22E;">push</span><span style="color:#F8F8F2;">(element);</span></span>
<span class="line highlighted"><span style="color:#88846F;">    // sort the queue so that the element with highest priority (i.e. smallest time)</span></span>
<span class="line highlighted"><span style="color:#88846F;">    // is at the beginning of the list</span></span>
<span class="line highlighted"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.queue.</span><span style="color:#A6E22E;">sort</span><span style="color:#F8F8F2;">((</span><span style="color:#FD971F;font-style:italic;">a</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">b</span><span style="color:#F8F8F2;">) </span><span style="color:#66D9EF;font-style:italic;">=&gt;</span><span style="color:#F8F8F2;"> a.time </span><span style="color:#F92672;">&lt;=</span><span style="color:#F8F8F2;"> b.time </span><span style="color:#F92672;">?</span><span style="color:#F92672;"> -</span><span style="color:#AE81FF;">1</span><span style="color:#F92672;"> :</span><span style="color:#AE81FF;"> 1</span><span style="color:#F8F8F2;">);</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">  }</span></span>
<span class="line highlighted"><wbr></span>
<span class="line highlighted"><span style="color:#88846F;">  // return the event with highest priority or \`null\` if the queue is empty</span></span>
<span class="line highlighted"><span style="color:#A6E22E;">  head</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line highlighted"><span style="color:#F92672;">    if</span><span style="color:#F8F8F2;"> (</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.queue.length </span><span style="color:#F92672;">&gt;</span><span style="color:#AE81FF;"> 0</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line highlighted"><span style="color:#F92672;">      return</span><span style="color:#FD971F;"> this</span><span style="color:#F8F8F2;">.queue[</span><span style="color:#AE81FF;">0</span><span style="color:#F8F8F2;">];</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">    } </span><span style="color:#F92672;">else</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line highlighted"><span style="color:#F92672;">      return</span><span style="color:#AE81FF;"> null</span><span style="color:#F8F8F2;">;</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">    }</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">  }</span></span>
<span class="line highlighted"><wbr></span>
<span class="line highlighted"><span style="color:#88846F;">  // delete the first element of the queue</span></span>
<span class="line highlighted"><span style="color:#A6E22E;">  deleteHead</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line highlighted"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.queue.</span><span style="color:#A6E22E;">shift</span><span style="color:#F8F8F2;">();</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">  }</span></span>
<span class="line highlighted"><span style="color:#F8F8F2;">}</span></span></code></pre></div><p>Then, we can implement our <code>LookaheadScheduler</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#88846F;">// ./main.js</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">class</span><span> </span><span style="color:#A6E22E;text-decoration:underline;">LookaheadScheduler</span><span style="color:#F8F8F2;"> {</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">  constructor</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.priorityQueue </span><span style="color:#F92672;">=</span><span style="color:#F92672;"> new</span><span style="color:#A6E22E;"> PriorityQueue</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.period </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0.05</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.lookahead </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 0.1</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    // make sure the tick method is called with the right \`this\` context,</span></span>
<span class="line"><span style="color:#88846F;">    // whatever its call context (welcome to JavaScript :)</span></span>
<span class="line"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.tick </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> this</span><span style="color:#F8F8F2;">.tick.</span><span style="color:#A6E22E;">bind</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#88846F;">    // launch the periodic \`tick\` call</span></span>
<span class="line"><span style="color:#A6E22E;">    setInterval</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.tick, </span><span style="color:#FD971F;">this</span><span style="color:#F8F8F2;">.period </span><span style="color:#F92672;">*</span><span style="color:#AE81FF;"> 1000</span><span style="color:#F8F8F2;">);</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6E22E;">  add</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">event</span><span style="color:#F8F8F2;">, </span><span style="color:#FD971F;font-style:italic;">time</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#88846F;">    // insert the event, time pair into the queue</span></span>
<span class="line"><span style="color:#FD971F;">    this</span><span style="color:#F8F8F2;">.priorityQueue.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">(event, time);</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">  // This function is executed by the \`setInterval\` every 50 ms.</span></span>
<span class="line"><span style="color:#88846F;">  // This is where all the magic happens</span></span>
<span class="line"><span style="color:#A6E22E;">  tick</span><span style="color:#F8F8F2;">() {</span></span>
<span class="line"><span style="color:#88846F;">    // get the current time of the audio context and the current head of the queue</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    const</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.currentTime;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">    let</span><span style="color:#F8F8F2;"> head </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> this</span><span style="color:#F8F8F2;">.priorityQueue.</span><span style="color:#A6E22E;">head</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">    // unstack the queue while the head is in the time frame defined by the lookahead</span></span>
<span class="line"><span style="color:#F92672;">    while</span><span style="color:#F8F8F2;"> (head </span><span style="color:#F92672;">&amp;&amp;</span><span style="color:#F8F8F2;"> head.time </span><span style="color:#F92672;">&lt;</span><span style="color:#F8F8F2;"> now </span><span style="color:#F92672;">+</span><span style="color:#FD971F;"> this</span><span style="color:#F8F8F2;">.lookahead) {</span></span>
<span class="line"><span style="color:#88846F;">      // the head will be processed so we can remove it from the queue</span></span>
<span class="line"><span style="color:#FD971F;">      this</span><span style="color:#F8F8F2;">.priorityQueue.</span><span style="color:#A6E22E;">deleteHead</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#88846F;">      // pick the time and event from the head</span></span>
<span class="line"><span style="color:#88846F;">      // the time of the event is not \`now\`, it is somewhere between now and now + lookahead</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">      const</span><span style="color:#F8F8F2;"> time </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> head.time;</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">      const</span><span style="color:#F8F8F2;"> event </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> head.event;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">      // Execute the event giving it its time as argument.</span></span>
<span class="line"><span style="color:#88846F;">      // If the event returns a new time, i.e. it wants to be called again later,</span></span>
<span class="line"><span style="color:#88846F;">      // we can re-insert it right away into the queue.</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">      const</span><span style="color:#F8F8F2;"> nextTime </span><span style="color:#F92672;">=</span><span style="color:#A6E22E;"> event</span><span style="color:#F8F8F2;">(time);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F92672;">      if</span><span style="color:#F8F8F2;"> (nextTime) {</span></span>
<span class="line"><span style="color:#FD971F;">        this</span><span style="color:#F8F8F2;">.priorityQueue.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">(event, nextTime);</span></span>
<span class="line"><span style="color:#F8F8F2;">      }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">      // pick the next event in the queue and check if it is in the lookahead</span></span>
<span class="line"><span style="color:#F8F8F2;">      head </span><span style="color:#F92672;">=</span><span style="color:#FD971F;"> this</span><span style="color:#F8F8F2;">.priorityQueue.</span><span style="color:#A6E22E;">head</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">    }</span></span>
<span class="line"><span style="color:#F8F8F2;">  }</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span></code></pre></div><p>Finally let&#39;s just implement a simple metronome that we will register into the scheduler, and everything together:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki monokai vp-code"><code><span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> BPM </span><span style="color:#F92672;">=</span><span style="color:#AE81FF;"> 60</span><span style="color:#F8F8F2;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">function</span><span style="color:#A6E22E;"> metro</span><span style="color:#F8F8F2;">(</span><span style="color:#FD971F;font-style:italic;">currentTime</span><span style="color:#F8F8F2;">) {</span></span>
<span class="line"><span style="color:#F8F8F2;">  console.</span><span style="color:#A6E22E;">log</span><span style="color:#F8F8F2;">(currentTime);</span></span>
<span class="line"><span style="color:#88846F;">  // play some sound at \`currentTime\`</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">  const</span><span style="color:#F8F8F2;"> src </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> audioContext.</span><span style="color:#A6E22E;">createBufferSource</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#F8F8F2;">  src.buffer </span><span style="color:#F92672;">=</span><span style="color:#F8F8F2;"> buffer;</span></span>
<span class="line"><span style="color:#F8F8F2;">  src.</span><span style="color:#A6E22E;">connect</span><span style="color:#F8F8F2;">(audioContext.destination);</span></span>
<span class="line"><span style="color:#F8F8F2;">  src.</span><span style="color:#A6E22E;">start</span><span style="color:#F8F8F2;">(currentTime);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">  // return the next time we want to do something</span></span>
<span class="line"><span style="color:#F92672;">  return</span><span style="color:#F8F8F2;"> currentTime </span><span style="color:#F92672;">+</span><span style="color:#AE81FF;"> 60</span><span style="color:#F92672;"> /</span><span style="color:#F8F8F2;"> BPM;</span></span>
<span class="line"><span style="color:#F8F8F2;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#88846F;">// create a new LookaheadScheduler</span></span>
<span class="line"><span style="color:#66D9EF;font-style:italic;">const</span><span style="color:#F8F8F2;"> scheduler </span><span style="color:#F92672;">=</span><span style="color:#F92672;"> new</span><span style="color:#A6E22E;"> LookaheadScheduler</span><span style="color:#F8F8F2;">();</span></span>
<span class="line"><span style="color:#88846F;">// add the metronome to the scheduler, starting now</span></span>
<span class="line"><span style="color:#F8F8F2;">scheduler.</span><span style="color:#A6E22E;">add</span><span style="color:#F8F8F2;">(metro, audioContext.currentTime);</span></span></code></pre></div><p>If you reload the page, you should now ear a very nice metronome at 60 BPM:</p>`,48),F=["src"],h=s('<p>Congrats! You have implemented a very simple yet working lookahead scheduler</p><h3 id="going-further" tabindex="-1">Going further <a class="header-anchor" href="#going-further" aria-label="Permalink to &quot;Going further&quot;">​</a></h3><p>Of course, this scheduler is very simple and misses a lot of functionality, but you have a basis to build upon if you which. For example you could</p><ul><li>Implement the logic to remove a scheduled event from the queue, e.g. to stop the metronome and more advanced synthesis engine)</li><li>Stop and restart the scheduler on demand.</li></ul><p>You could also improve the demo by:</p><ul><li>Inserting the <code>FeedbackDelay</code> in the graph so that you can check that the jitter issue we add in last tutorial is now solved</li><li>Adding some control over the BPM of the metronome.</li></ul><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>In this tutorial, you have learned the why and how of lookahead schedulers. In particular why they are needed to mitigate the lack of precision of regular JavaScript timers, and how you can implement a simple version it.</p><p>In the next tutorial, we will build upon this knowledge and tools to learn how to implement a rather powerful and versatile synthesis technique: the <em>granular synthesis</em>.</p>',9),f=JSON.parse('{"title":"Timing and Scheduling","description":"","frontmatter":{},"headers":[],"relativePath":"scheduling/timing-and-scheduling.md","filePath":"scheduling/timing-and-scheduling.md"}'),y={name:"scheduling/timing-and-scheduling.md"},w=Object.assign(y,{setup(d){return(u,m)=>(l(),a("div",null,[r,n("audio",{controls:"",loop:"",src:e(o)("/static-assets/metronome-with-scheduler.m4a")},null,8,F),h]))}});export{f as __pageData,w as default};
